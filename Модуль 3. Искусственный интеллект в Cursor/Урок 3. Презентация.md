[[Урок 3. Тестирование с помощью AI]]
## **Слайд 1 — Титульный

**Заголовок:** Тестирование с AI в Cursor

**Подзаголовок:** Unit · Интеграция · Покрытие · Генерация кейсов

**Тезисы:** AI ускоряет написание тестов и поиск пробелов

**Notes (2:00):** цель — научиться просить AI писать осмысленные тесты, закрывать углы и анализировать покрытие.

---

## **Слайд 2 — План и результат**

**Тезисы:**

1. Unit-тесты: генерация, моки, параметризация
    
2. Интеграционные тесты: API/UI
    
3. Покрытие кода и «дыры»
    
4. Практика: дописываем недостающие кейсы
    
    **Notes (0:45):** критерий успеха — +10–30% покрытия по ветвлениям без флаков.

---

## **Слайд 3 — Принципы «хорошего» теста**

**Тезисы:**

- AAA: Arrange-Act-Assert
    
- Детерминизм: без сети/часов/рандома (или зафиксировать)
    
- Один смысл — один тест
    
- Имена тестов = требования
    
    **Notes (1:00):** AI помогает со скелетом, вы отвечаете за инварианты и стабильность.

---

## **Слайд 4 — Настройка тестового окружения

**Тезисы:**

- Выбор раннера: **Vitest** (JS/TS) или **Jest**
    
- Скрипты в package.json: test, test:watch, coverage
    
    **Сниппет (Vitest):**

```
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "coverage": "vitest run --coverage"
  }
}
```

**Notes (1:15):** держите минимальную конфигурацию; остальное — по проекту.

---

## **Слайд 5 — Генерация unit-тестов с AI

**Тезисы:**

- Дайте контекст: файл/функция/ожидания
    
- Просите **не менять исходники**, только __tests__/
    
- Уточняйте граничные случаи и ошибки
    
    **Notes (2:00):** лучше несколько узких промптов, чем один общий.  

**Промпт (копируй-вставляй):**

«Сгенерируй unit-тесты для src/utils/sortByDate.ts (Vitest). Покрой: пустой массив, некорректные даты, равные даты (стабильность), desc. **Не меняй исходный код**, работай в tests/. Формат AAA и понятные названия.»

---

## **Слайд 6 — Параметризованные тесты**

**Тезисы:**

- Меньше дублирования — больше охват
    
- Табличные кейсы

---

## **Слайд 7 — Моки, стабы, таймеры**

**Тезисы:**

- Изолируйте внешние зависимости (HTTP/DB/clock/random)
    
- Подменяйте Date.now, Math.random, сетевые вызовы

**Notes (1:30):** AI попросите сразу добавить моки и reset в afterEach.

---

## **Слайд 8 — От генерации к качеству**

**Тезисы:**

- Просите **объяснение**, что проверяет каждый тест
    
- Не берите «лишнюю магию»: простые утверждения лучше
    
    **Промпт:**
    
    «Для каждого теста напиши одно предложение — какая ветка/требование покрывается. Если дублируется — объедини кейсы.»

---

## **Слайд 9 — Интеграционные тесты API

**Тезисы:**

- **supertest**: Express/Fastify без сети
    
- Изолируйте слой данных (in-memory/моки)

**Notes (2:00):** AI может накидать «сквозные» кейсы: 200/401/429.

---

## **Слайд 10 — Интеграционные тесты UI (Playwright)**

**Тезисы:**

- E2E без боли: запуск локально, фикстуры
    
- Локаторы по роль/текст — стабильнее, чем по селекторам

**Notes (1:45):** попросите AI писать **устойчивые** локаторы.

---

## **Слайд 11 — Покрытие кода: что мерить**

**Тезисы:**

- **Lines/Statements/Branches/Functions**
    
- Смотрим **ветви** (branch) для реальной уверенности

**Notes (1:15):** не гонимся за 100%, целимся в разумный порог (напр., 80% branches).

---

## **Слайд 12 — AI как «охотник за дырами»**

**Тезисы:**

- Пусть найдет непокрытые ветки и предложит кейсы
    
- Требуйте ссылку на строки/ветви
    
    **Промпт:**
    
    «Проанализируй отчёт покрытия (ветви). Составь список непокрытых условий с файлами и строками. Предложи минимальные тесты для закрытия, без дубликатов.»

---

## **Слайд 13 — Борьба с flaky-тестами**

**Тезисы:**

- Убрать зависимости от времени/сети/рандома
    
- Ретрай → только временно
    
- Локаторы и ожидания — явные
    
    **Notes (1:15):** попросите AI «стабилизировать тест» и объяснить причину флейка.

---

## **Слайд 14 — Анти-паттерны генерации тестов**

**Тезисы:**

- Тесты, повторяющие исходный код
    
- Утверждения «ни о чём» (toBeDefined)
    
- Сеть/файлы в unit-тестах
    
- Массовая генерация без чтения
    
    **Notes (1:00):** всегда просматривайте дифф и смысл.

---

## **Слайд 15 — Микро-демо

**Задача:** дописать тесты и поднять покрытие ветвей

**Шаги:**

1. sortByDate — запрос на unit-тесты (Слайд 5).
    
2. Запуск coverage → показать непокрытую ветку.
    
3. Промпт «закрой ветвь X строка Y» (Слайд 12) → добавить тест.
    
4. Повторный coverage → сравнить значение.
    
    **Notes:** держите маленький проект и готовый конфиг.

---

## **Слайд 16 — Практика

**Задание:**

- Сгенерируйте тесты для функции из вашего проекта (без сети/IO)
    
- Поднимите покрытие ветвей хотя бы на 10%
    
- Зафиксируйте два граничных случая
    
    **Критерии:** новые тесты стабильны; отчёт coverage улучшился.    

---

## **Слайд 17 — Подсказки промптов (скопируй-вставляй)**

- «Сгенерируй unit-тесты (Vitest) для X. Покрой позитив/негатив/границы. Не меняй исходники, работай в tests/.»
    
- «Стабилизируй этот флейковый тест: объясни причину и предложи фикс (локаторы/таймер/моки). Покажи diff.»
    
- «Сделай интеграционный тест API с **supertest**: 200/401/429. Подмени хранилище in-memory.»
    
- «Проанализируй coverage (branches) и предложи минимальный набор недостающих тестов со ссылками на строки.»

---

## **Слайд 18 — Итоги

  

**Тезисы:**

- AI быстро создаёт «скелет» тестов и предлагает недостающие кейсы
    
- Вы отвечаете за инварианты, стабильность и осмысленность