[[Урок 1. Автодополнение и генерация кода]]
## **Слайд 1 — Титульный

**Заголовок:** Автодополнение и генерация кода в Cursor

**Подзаголовок:** Быстрые подсказки, точные промпты, улучшение результата

**Тезисы:** учимся управлять AI-подсказками и заказывать готовые функции

**Notes (2:00):** «Сегодня: как приручить автодополнение, как правильно формулировать запросы к AI, как улучшать и тестировать полученный код».

---

## **Слайд 2 — План и результат**

**Тезисы:**

1. Автодополнение: приёмы и настройки
    
2. Генерация функций «под задачу»
    
3. Улучшение и доводка результата
    
4. Мини-тесты и критерии качества
    
    **Notes (0:45):** критерий успеха — за урок вы сгенерируете функцию, улучшите её и покроете тестами.

---

## **Слайд 3 — Как работает автодополнение**

**Тезисы:**

- «Серые» inline-подсказки в реальном времени
    
- Завязка на контекст файла/проекта
    
- Принять: **Tab** · Отклонить: **Esc**
    
    **Notes (1:30):** покажите один «верный» и один «ложный» пример — обучаемся фильтровать.

---

## **Слайд 4 — Автодополнение в React (живой пример)**

**Тезисы:**

- Пропишите комментарий-намерение → подсказка точнее
    
- Компонент, события, сеттеры состояния — «знает по имени»
    
- Быстрый цикл: принять → сразу мелкая правка
    
    **Notes (2:00):** набросайте useEffect + обработчик, примите подсказку, подправьте.

---

## **Слайд 5 — Управление «агрессивностью» подсказок**

**Тезисы:**

- Включить/отключить inline и триггеры символами
    
- «Умное» принятие Enter, таб-комплишн
    
- Настройка по языкам (TS/JS/Python …)
    
    **Notes (2:00):** покажите, как сделать подсказки менее навязчивыми в строках/комментариях.

**Сниппет settings.json:**

```
{
  "editor.inlineSuggest.enabled": true,
  "editor.suggestOnTriggerCharacters": true,
  "editor.quickSuggestions": { "other": true, "comments": false, "strings": true },
  "editor.suggest.selection": "recentlyUsedByPrefix",
  "editor.acceptSuggestionOnEnter": "smart",
  "editor.tabCompletion": "on",
  "javascript.suggest.completeFunctionCalls": true,
  "typescript.suggest.completeFunctionCalls": true,
  "editor.wordBasedSuggestions": "currentDocument"
}
```

---

## **Слайд 6 — Антипаттерны автодополнения**

**Тезисы:**

- Принимать большие блоки «вслепую»
    
- Позволять подсказкам менять стиль/парадигму проекта
    
- Игнорировать линтер/форматер после вставки
    
    **Notes (1:00):** правило: «малые порции + чтение diff + форматирование».

---

## **Слайд 7 — Генерация функций: постановка задачи

**Тезисы:**

- Контекст: вход/выход, ограничения, формат ошибок
    
- Критерии приёма: сложность, детерминизм, тесты
    
- Просьба о чистых функциях и иммутабельности
    
    **Notes (2:00):** давайте «рамки» (язык, папка, типы, покрытие).


**Промпт (копируй-вставляй):**

«Напиши чистую функцию sortByDate(items, selector) на TypeScript, которая сортирует массив объектов по дате (ISO/Date). Не мутируй вход. Обработай некорректные даты (пропусти). Сложность O(n log n). Дай JSDoc и примеры.»

---

## **Слайд 8 — Генерация: базовая реализация

**Тезисы:**

- Вставляем код → читаем сигнатуру и крайние случаи
    
- Проверяем иммутабельность и стабильность сортировки
    
    **Notes (3:00):** укажите «без eval/any», проверьте типы.

---

## **Слайд 9 — Обсуждение результата и доработка

**Тезисы:**

- Попросить стабилизировать сортировку при равенстве дат
    
- Добавить опцию направления (asc/desc)
    
- Обработка таймзоны/локали — по задаче
    
    **Notes (3:00):** просим показать **diff** вместо полного кода.
  
**Промпт:**

«Добавь параметр order: 'asc' | 'desc', сделай сортировку стабильной, оставь иммутабельность. Покажи только diff.»

---

## **Слайд 10 — Улучшение: читаемость и комментарии

**Тезисы:**

- Попросить JSDoc/комменты «почему так»
    
- Именованные переменные, guard-ветки
    
- Примеры использования в JSDoc
    
    **Notes (2:00):** комментарии — не «что», а «зачем».

---

## **Слайд 11 — Мини-тесты

**Тезисы:**

- Сгенерировать тесты: позитив/равные даты/плохие входы
    
- Прогон через Vitest/Jest
    
- «Красный → зелёный → рефакторинг»
    
    **Notes (3:00):** держите готовый vitest скрипт.

**Промпт:**

«Добавь Vitest и тесты для sortByDate: пустой ввод, равные даты (стабильность), desc, пропуск плохих дат. Обнови package.json (scripts).»

---

## **Слайд 12 — Оптимизация и альтернативы

**Тезисы:**

- Профилирование горячих участков (если нужно)
    
- Вынести парсинг дат в отдельную функцию/кеш
    
- Рассмотреть Intl APIs при форматировании
    
    **Notes (2:00):** коротко обсудите сложность и память.

---

## **Слайд 13 — Улучшение результата

**Тезисы:**

- Просим AI упростить, дать варианты, объяснить trade-offs
    
- Привести код к правилам линтера/форматера
    
    **Notes (3:00):** покажите «до/после» с сохранением поведения.


**Промпт:**

«Сделай код проще без потери функциональности, соблюдай ESLint/Prettier. Объясни, что упростил, и почему поведение не изменилось.»

---

## **Слайд 14 — Антипаттерны генерации**

**Тезисы:**

- «Напиши что-нибудь» — слишком общий запрос
    
- Отсутствие критериев приёма и тестов
    
- Принятие больших правок без просмотра diff
    
    **Notes (1:00):** чек-лист: рамки → код → diff → тест.
    

---

## **Слайд 15 — Микро-демо

**Задача:** от запроса до тестов

**Шаги:**

1. В utils/sort.ts → промпт из Слайда 7.
    
2. Принять код, включить **Format on Save** → посмотреть diff.
    
3. Промпт на параметр order + стабильность → принять **diff**.
    
4. Промпт на тесты (Vitest) → npm test.
    
    **Notes:** держите заготовленный проект; если AI медлит — переключитесь на заранее сохранённые диффы.


---

## **Слайд 16 — Практика

**Задание:**

- Сгенерируйте groupBy(arr, key) (без внешних lib), иммутабельно
    
- Доработайте: тип-«ключ» как keyof T или селектор
    
- Попросите AI добавить тесты (3–4 кейса)
    
    **Критерии:** чистая функция, тесты проходят, код читаем.

---

## **Слайд 17 — Подсказки промптов

- «Напиши чистую функцию groupBy(items, keyOrSelector) с дженериками, без мутаций, верни Record<string, []>. Добавь JSDoc и примеры.»
    
- «Предложи 3 альтернативные реализации моей функции: иммутабельный reduce, Map + преобразование, сортировка + single pass. Объясни плюсы/минусы.»
    
- «Сгенерируй тесты: позитив, пустой массив, дубликаты ключей, неожиданные значения. Обнови package.json со скриптом test.»

---

## **Слайд 18 — Итоги

**Тезисы:**

- Автодополнение = микроускорение, генерация = «крупные куски»
    
- Рамки и критерии делают результат предсказуемым