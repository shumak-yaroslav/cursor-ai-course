[[Урок 1. Prompt Engineering для разработчиков]]

**Заголовок:** Prompt Engineering для разработчиков

**Подзаголовок:** Контекст → Задача → Формат → Критерии

**Тезисы:** точный запрос = предсказуемый результат

**Notes (2–3):** цель — научиться формулировать запросы так, чтобы AI генерировал полезный, проверяемый и безопасный код.

---

## **Слайд 2 — План и результат**

**Тезисы:**

1. Базовые принципы и «каркас» промпта
    
2. Многошаговые запросы и разбиение задач
    
3. Форматы ответов: diff, файлы, таблицы
    
4. Практика «улучши мой промпт»
    
    **Итог:** 5 готовых шаблонов + чек-лист проверки промпта.

---

### **БЛОК 1. БАЗОВЫЕ ПРИНЦИПЫ

## **Слайд 3 — Каркас «идеального» промпта**

**Тезисы (5 компонентов):**

1. **Контекст** (стек, версии, файлы, ограничения)
    
2. **Задача** (что сделать, что не делать)
    
3. **Формат ответа** (diff/файл/список шагов)
    
4. **Критерии приёмки** (тесты, линтер, производительность)
    
5. **Ограничения** (не менять публичный API, трогать только src/utils/)
    
    **Notes (2:00):** чем меньше лишнего контекста — тем лучше.

**Шаблон:**

```
Контекст: {стек, файлы, версии}. 
Задача: {что именно}. 
Формат: {diff|файлы|таблица}. 
Критерии: {тесты/линтер/время}. 
Ограничения: {что не трогать}.
```

---

## **Слайд 4 — Минимальные пары: сила контекста**

**Плохой:** «Напиши функцию сортировки.»

**Хороший:** «Напиши функцию **на TypeScript**, сортирующую массив {id:number,date:string} по дате убыв., **стабильную**, со **временной сложностью O(n log n)**, добавь **2 юнит-теста (Jest)**. **Формат: один файл src/sort.ts + tests/sort.test.ts.**»

**Notes (2:00):** покажите, как меняется качество результата.

---

## **Слайд 5 — Контекст из Cursor**

**Тезисы:**

- Выделяйте конкретные файлы/дифф → **Cmd/Ctrl+K**
    
- Суммаризируйте проект в 5–8 буллетов и используйте эти термины
    
- Для больших задач — работайте пакетами (папка → модуль → файл)
    
    **Пример промпта:**
    
    «Используй только src/utils/date.ts и src/types.ts. Работай в src/utils/. Не меняй публичные типы из src/types.ts.»

---

### **БЛОК 2. МНОГОШАГОВЫЕ ЗАПРОСЫ

## **Слайд 6 — Делим на этапы**

**Тезисы:**

1. Сначала — **план**: шаги + риски + критерии
    
2. Затем — реализация по шагам с **diff**
    
3. В конце — тесты/проверка критериев
    
    **Пример цепочки:**

- «Составь архитектуру API для ToDo (эндпоинты/схемы).»
    
- «Создай роуты для регистрации/логина (Express, TS). Формат: diff.»
    
- «Напиши 4 теста (supertest) + скрипт test в package.json.»
  

**Промпт (шаблон этапа 1 — план):**

«Сначала дай **план** из 5–7 шагов с оценкой сложности (S/M/L) и рисков. Только после моего “ОК” переходи к шагу 1. Формат: нумерованный список.»

---

## **Слайд 7 — Просим понятный формат**

**Тезисы:**

- Для правок кода — **unified diff**
    
- Для архитектуры — **таблица/mermaid**
    
- Для задач — **чек-лист**
    
    **Примеры форматов:**
    
- «Верни **только** unified diff.»
    
- «Дай диаграмму зависимости модулей в **mermaid** (уровень папок).»
    
- «Список задач в формате чек-листа [ ]/[x].»

---

## **Слайд 8 — Пример «многошаговки» (развёрнутый)**


**Шаг 1 (план) → Шаг 2 (реализация роута) → Шаг 3 (тесты) → Шаг 4 (README-фрагмент)**

**Notes (3:00):** важно закрепить «план → дифф → тест».

---
## **Слайд 9 — MCP в 2 фразы**

**Тезисы:**

- **Model Context Protocol** — способ подключить к AI внешние **источники данных** и **инструменты** (поиск по коду, БД, REST, файлы), чтобы он использовал их при решении задач.
    
- Взаимодействуют: **клиент** (IDE/чат) ↔ **MCP-сервер(ы)** (набор capabilities: tools/resources).
    
    **Notes:** мыслите как «плагины для AI», но стандартизировано.

---

## **Слайд 10 — Что подключать через MCP**

**Примеры capabilities:**

- **repo.search / readFile** — умный поиск по монорепе, чтение фрагментов по путям/строкам
    
- **http.get / http.post** — REST-провайдер (моки/стейдж)
    
- **db.query** — чтение (readonly) метрик/агрегатов
    
- **docs.get** — вытягивание внутренних spec/ADR/правил
    
    **Notes:** чем ближе инструмент к задаче — тем меньше «галлюцинаций».

---
## **Слайд 11 — Зачем User Rules**

**Тезисы:**

- Ваш персональный «голос» и предпочтения: стиль кода, формат ответов, язык объяснений, уровень строгости.
    
- Применяются **ко всем проектам** в вашей IDE/аккаунте.
    
    **Notes:** держим их короткими и конкретными.

---
## **Слайд 12 — Зачем Project Rules**

**Тезисы:**

- Единый стиль и архитектурные границы для **конкретного репозитория**.
    
- Применимы всем в команде (версионируются в репо).
    
    **Notes:** Project Rules дополняют, а при конфликте переопределяют User Rules.
    

---
### **БЛОК 3. ПРАКТИКА «AI КАК СОБЕСЕДНИК»

  ## **Слайд 13 — Задание 1: «как получится» → «идеально»**

**Инструкция:**

1. Возьмите сложную функцию из проекта.
    
2. Запрос 1: «Перепиши как считаешь лучше».
    
3. Запрос 2: добавьте **контекст, формат, критерии**.
    
4. Сравните диффы и качество.
    
    **Критерии:** поведение не изменилось, читаемость выше, тесты зелёные.

---

## **Слайд 14 — Шаблоны промптов

**Генерация функции (TS):**

```
Контекст: React+TS, Vitest. 
Задача: функция фильтра задач по статусу/поиску, стабильная сортировка по дате убыв. 
Формат: файл `src/filter.ts` + `tests/filter.test.ts`. 
Критерии: покрыть пустой список/некорректные даты/равные даты/регистронезависимый поиск. 
Ограничения: типы из `src/types.ts` не менять.
```

**Рефакторинг без изменения API:**

```
Работай только в `src/utils/date.ts`. 
Перепиши функции в функциональном стиле, без мутаций, сохрани экспорт и сигнатуры. 
Формат: unified diff + краткое объяснение каждого хунка (1–2 предложения).
```

**Поиск багов + фиксы:**

```
Проанализируй `applyDiscount`. Дай 3 потенциальных бага с примерами входов. 
Верни diff с фиксом и поясни риски.
```

**Тесты (Vitest + RTL):**

```
Сгенерируй тесты для `ToDoList`: empty/loading/error/ok, событие onToggle. 
Формат: `tests/ToDoList.test.tsx`. Прод-код не менять.
```

**Документация (README-фрагмент):**

```
Собери раздел README: Установка/Запуск/Тесты/Конфиг (VITE_API_URL). 
Формат: Markdown без прелюдий.
```

---

## **Слайд 15 — Управление контекстом и бюджетом**

**Тезисы:**

- «Коротко о проекте» (5 буллетов) — в начало каждого запроса
    
- При длинных файлах — процитируйте **фрагменты**, а не весь файл
    
- «Если правок >50 строк — сначала план, затем шаг за шагом»
    
    **Notes (2:00):** экономим токены и повышаем управляемость.
    

---

## **Слайд 16 — Чек-лист хорошего промпта**

- Есть **контекст** (стек, файлы, версии)
    
- Чёткая **задача** и **ограничения**
    
- Запрошен **формат** (diff/файл/таблица)
    
- Определены **критерии приёмки** (тест/линтер/перф)
    
- Работа **пакетами** (малые шаги), большой объём → «сначала план»

---

## **Слайд 17 — Анти-паттерны**

**Тезисы:**

- «Сделай лучше как считаешь» → хаос
    
- Сразу огромный контекст → шум и цена
    
- Нет формата → «простыня» текста без диффов
    
- Нет критериев → непроверяемый результат
    
    **Notes (1:30):** лечится каркасом из Слайда 3.

---

### **МИКРО-ДЕМО

## **Слайд 18 — Демонстрация «сырой → идеальный»**

**Шаги:**

1. Показать плохой промпт и средний ответ.
    
2. Превратить его в каркас (контекст/формат/критерии).
    
3. Получить diff + тесты.
    
    **Notes:** используйте небольшую функцию/компонент.

---

## **Слайд 19 — Шпаргалка промптов (один слайд)**

- «Верни **только diff**. Если >50 строк — сначала план.»
    
- «Работай **только** в src/utils/. Публичный API не менять.»
    
- «Добавь 4 теста: пустой/ошибочный вход/границы/успех.»
    
- «Дай **mermaid**-диаграмму модулей (уровень папок).»
    
- «Сжать контекст до 5 буллетов перед следующими шагами.»
    

---

## **Слайд 20 — Итоги

**Тезисы:**

- Каркас промпта = управляемый результат
    
- Форматы ответов (diff/файлы) = быстрый код-ревью