[[Урок 3. Git и управление версиями]]
## **Слайд 1 — Титульный

**Заголовок:** Git в Cursor: коммиты, ветки, история

**Подзаголовок:** Всё из IDE + помощь AI

**Тезисы:** работаем с Git без терминала; AI пишет понятные сообщения коммитов

**Notes (2:00):** «Сегодня: (1) базовые операции, (2) ветки, (3) история и diff, (4) коммиты с AI. В конце: своя ветка + PR-готовый коммит».

---

## **Слайд 2 — План и результат**

**Тезисы:**

1. Панель **Source Control** и базовые действия
    
2. Коммиты, diff, история, .gitignore
    
3. Ветки: создание/переключение/слияние
    
4. Сообщения коммитов с AI (conventional commits)
    
    **Notes (0:45):** «Критерии успеха: новый коммит в своей ветке, пуш в удалённый».

---

### **БЛОК 1. БАЗОВЫЕ КОМАНДЫ

## **Слайд 3 — Где живёт Git в Cursor**

**Тезисы:**

- Иконка **Source Control** в боковой панели
    
- Индикаторы изменённых файлов: M (modified), U (untracked), D (deleted)
    
- Статус-бар: текущая ветка, синхронизация
    
    **Notes (1:30):** быстро показать список изменений и кнопку **Commit**.  

**Визуал:** панель Source Control с пометками M/U/D.

---

## **Слайд 4 — Staging и коммит**

**Тезисы:**

- Выделить файл → **Stage** (или Stage All)
    
- Просмотреть **diff** до коммита
    
- Ввести сообщение → **Commit**
    
    **Notes (2:00):** совет: мелкие логичные коммиты; один смысл — один коммит.


**Визуал:** diff-панель «до/после», кнопка Stage.

---

## **Слайд 5 — Push/Pull/Sync**

**Тезисы:**

- **Push** отправляет коммиты в удалённый
    
- **Pull** подтягивает изменения (fetch+merge/rebase по настройкам)
    
- **Sync** — удобная кнопка «в обе стороны»
    
    **Notes (1:30):** подчеркните: перед началом работы — **Pull**, перед перерывом — **Push**.

---

## **Слайд 6 — История и blame**

**Тезисы:**

- История коммитов по файлу/репозиторию
    
- **Blame**: кто менял строку и когда
    
- Быстро перейти к коммиту/автору/дате
    
    **Notes (1:30):** применяйте для расследований и код-ревью.

---

## **Слайд 7 — .gitignore и «чистота репо»**

**Тезисы:**

- Исключаем node_modules, сборки, секреты
    
- Добавить/обновить .gitignore (через шаблон или AI)
    
    **Notes (1:00):** объясните риск случайной публикации .env.

**Сниппет:**

```
node_modules
dist
build
.env
*.log
```

### **БЛОК 2. ВЕТКИ И AI-КОММИТЫ

## **Слайд 8 — Ветки: зачем и как**

**Тезисы:**

- Ветка = независимая линия разработки
    
- Имена: feat/*, fix/*, chore/*
    
    **Notes (1:00):** правило: одна задача — одна ветка.

---

## **Слайд 9 — Создать/переключить/удалить ветку**

**Тезисы:**

- **Create Branch** от текущей точки (обычно от main)
    
- **Checkout** для переключения
    
- Удаление локальной ветки после merge
    
    **Notes (1:45):** покажите меню веток и индикатор текущей ветки.

---

## **Слайд 10 — Merge/Rebase (когда что)**

**Тезисы:**

- **Merge**: сохраняет историю ветвлений (быстрее, безопаснее)
    
- **Rebase**: линейная история (аккуратно, лучше до публикации)
    
    **Notes (1:45):** для урока — используем merge в UI; rebase оставьте как опцию для продвинутых.

---

## **Слайд 11 — Конфликты слияния: быстрый разбор**

**Тезисы:**

- Файлы с конфликтом подсвечены
    
- Маркеры <<<<<<, ======, >>>>>>
    
- Выбрать «текущую/входящую/оба» изменения, проверить сборку
    
    **Notes (2:00):** правило: сначала понять намерение обеих сторон; после выбора — тесты и новый коммит «resolve conflicts».

**Визуал:** редактор с конфликт-маркерами.

---

## **Слайд 12 — Сообщения коммитов с AI**

**Тезисы:**

- Выделяем staged-изменения → просим AI «суммаризировать»
    
- Выбираем стиль: **Conventional Commits**
    
- Двуязычные сообщения (ru/en) — при необходимости
    
    **Notes (1:30):** покажите, как AI предлагает заголовок и body, вы редактируете.


**Промпт (копируй-вставляй):**

«Проанализируй staged-изменения и предложи сообщение коммита в стиле **Conventional Commits**: краткий заголовок ≤72 символов и body со списком изменений. Язык — русский. Если есть ломающие изменения — добавь BREAKING CHANGE:.»

---

### **ПРАКТИКА И ЗАКРЫТИЕ 

## **Слайд 13 — Микро-демо

**Задача:** ветка → правка → коммит с AI → push → PR-готовность

**Шаги:**

1. Создать ветку feat/readme-badge.
    
2. Изменить README.md (добавить бейдж/секцию).
    
3. Просмотреть diff → Stage → запросить AI сообщение → **Commit**.
    
4. **Push** ветки в origin.
    
5. (Опционально) Открыть ссылку **Create PR** в браузере.
    
    **Notes:** держите небольшой проект/правку заранее.

---

## **Слайд 14 — Практика

**Задание:**

- Создать ветку feat/<ваше-имя>-shortcuts
    
- Добавить файл shortcuts.md с 5 любимыми хоткеями
    
- Сформировать сообщение коммита через AI (conventional commits)
    
- Push ветки в удалённый
    
    **Критерии:** ветка есть, коммит понятный, пуш успешен.

---

## **Слайд 15 — Восстановление, отмена и «спасжилеты»**

**Тезисы:**

- **Discard Changes** для файла/хунаков (осторожно)
    
- **Restore** из истории → вернуть удалённый файл
    
- **Revert commit** (без переписывания истории)
    
- **Amend** — поправить последний коммит (до пуша)
    
    **Notes (2:00):** правило безопасности: публичную историю не переписываем; для локальной — ok.

---

## **Слайд 16 — Антипаттерны и лайфхаки**

**Тезисы:**

- Огромные «сборные» коммиты без смысла
    
- Сообщения «fix»/«update» без контекста
    
- Пуш в main без PR/ревью
    
- Лайфхаки: мелкие коммиты, частые pull, ветки на задачу, AI-черновик сообщения + ручная правка
    
    **Notes (1:00):** покажите пример хорошего сообщения vs плохого.

---

## **Слайд 17 — Итоги

**Тезисы:**

- Умеем: stage/commit/push/pull, история и diff
    
- Работаем с ветками и конфликтами
    
- Генерируем понятные commit messages с AI