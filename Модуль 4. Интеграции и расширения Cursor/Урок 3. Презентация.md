[[Урок 3. Интеграции с внешними сервисами]]

## **Слайд 1 — Титульный

**Заголовок:** Интеграции: GitHub/GitLab · Docker · CI/CD

**Подзаголовок:** Автоматизируем разработку прямо из Cursor

**Notes:** цель — связать IDE с репозиториями и пайплайнами, научиться генерировать и поддерживать Docker/CI конфиги с помощью AI.

---

## **Слайд 2 — План и результат**

**Тезисы:**

1. Подключение GitHub/GitLab, работа с PR/MR и автодеплоем
    
2. Докеризация: Dockerfile, docker-compose.yml, dev/prod профили
    
3. CI/CD: GitHub Actions / GitLab CI — сборка, тесты, публикация образов/сайта
    
    **Итог:** в репо лежат рабочие Dockerfile, compose, .github/workflows/* или .gitlab-ci.yml, секреты настроены, пайплайн зелёный.

---

### **БЛОК 1. ИНТЕГРАЦИЯ С GITHUB / GITLAB

## **Слайд 3 — Подключение репозитория**

**Показываем:**

- В Cursor: **Open Repository / Clone from GitHub (или GitLab)**
    
- Авторизация через OAuth/SSH, выбор репо
    
- Создание рабочей ветки, коммит через Source Control
    
    **Notes:** включите protected branches и требование статусов перед merge.

**Промпт к AI (генерация .gitignore/.gitattributes):**

«Создай .gitignore для Node/React/TypeScript и .gitattributes (eol=lf, linguist overrides). Объясни кратко, что и зачем игнорируем.»

---

## **Слайд 4 — Автогенерация шаблонов PR/MR**

**Тезисы:** стандартизируем ревью и чек-лист.

```
## Что сделано
- ...

## Как проверить
- npm test
- npm run e2e

## Риски
- ...

## Чек-лист
- [ ] Тесты зелёные
- [ ] Без изменений API без ADR
```

**Промпт:** «Сгенерируй шаблон PR с разделами: Что, Как проверить, Риски, Чек-лист.»

---

## **Слайд 5 — Автодеплой из PR (превью)**

**Идея:** каждый PR → превью окружение.

**Тезисы:** GitHub Pages/Vercel/Netlify/Render/K8s review apps.

**Промпт:** «Подготовь workflow для превью окружения фронтенда на Vercel/Pages. Удаляй превью при закрытии PR.»

---

### **БЛОК 2. DOCKER

  ## **Слайд 6 — Базовый** 

## **Dockerfile**

##  **(Node/TS, multi-stage)**

```
# --- deps ---
FROM node:20-alpine AS deps
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN corepack enable && pnpm i --frozen-lockfile

# --- build ---
FROM node:20-alpine AS build
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN pnpm build

# --- runtime ---
FROM node:20-alpine AS app
WORKDIR /app
ENV NODE_ENV=production
COPY --from=build /app/dist ./dist
COPY package.json pnpm-lock.yaml ./
RUN corepack enable && pnpm i --prod --frozen-lockfile
EXPOSE 3000
CMD ["node","dist/index.js"]
```

**Notes:** multi-stage экономит размер; не забываем .dockerignore.

  

**Промпт:** «Сгенерируй multi-stage Dockerfile для Node/TS (pnpm), с кешированием зависимостей и переменными окружения. Объясни каждый слой в 3 строках.»

---

## **Слайд 7 — docker-compose.yml**

##  **для dev (web + db)**

```
version: "3.9"
services:
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_PASSWORD: dev
      POSTGRES_USER: dev
      POSTGRES_DB: app
    ports: ["5432:5432"]
    volumes: ["pgdata:/var/lib/postgresql/data"]
  api:
    build: .
    command: pnpm dev
    environment:
      DATABASE_URL: postgres://dev:dev@db:5432/app
    ports: ["3000:3000"]
    depends_on: [db]
    volumes:
      - .:/app
      - /app/node_modules
volumes:
  pgdata: {}
```

**Notes:** для локалки — маунтим код; для prod — только образ.

**Промпт:** «Сгенерируй docker-compose.yml для dev (api+postgres), с томом под БД и переменными окружения через .env.»

---

## **Слайд 8 — Профили: dev vs prod**

**Тезисы:**

- Dev: hot reload, volume mounts, NODE_ENV=development
    
- Prod: только image, healthchecks, ресурсы/лимиты
    
    **Промпт:** «Добавь профили dev/prod в compose и healthcheck для API.»

---

### **БЛОК 3. CI/CD (35:00–48:00)**

## **Слайд 9 — GitHub Actions: build + test (matrix)** 

.github/workflows/ci.yml

```
name: CI
on:
  pull_request:
  push:
    branches: [main]
jobs:
  build-test:
    runs-on: ubuntu-latest
    strategy:
      matrix: { node: [18, 20] }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: ${{ matrix.node }}, cache: 'pnpm' }
      - run: corepack enable
      - run: pnpm i --frozen-lockfile
      - run: pnpm lint && pnpm test -- --run
      - run: pnpm build
```

**Notes:** кеширование, матрица Node, быстрый фидбек.

---

## **Слайд 10 — Публикация Docker-образа (GHCR)**

.github/workflows/release-docker.yml

```
name: Release Docker
on:
  push:
    tags: ["v*.*.*"]
jobs:
  docker:
    runs-on: ubuntu-latest
    permissions: { contents: read, packages: write }
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ github.ref_name }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

**Notes:** тэг по версии, кэш buildx, права packages:write.

---

## **Слайд 11 — GitLab CI эквивалент (кратко)**

.gitlab-ci.yml

```
stages: [ci, docker]
image: node:20-alpine

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths: [node_modules/]

ci:
  stage: ci
  script:
    - corepack enable
    - pnpm i --frozen-lockfile
    - pnpm lint && pnpm test -- --run
    - pnpm build
  artifacts:
    paths: [dist/]

docker:
  stage: docker
  image: docker:24-git
  services: [docker:24-dind]
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
  rules:
    - if: '$CI_COMMIT_TAG'
```

**Notes:** dind для билда образа; публикация по тэгу.

---

## **Слайд 12 — Секреты и окружения**

**Тезисы:**

- GitHub: **Settings → Secrets and variables → Actions**
    
- GitLab: **Settings → CI/CD → Variables**
    
- Делим **dev/stage/prod**; principle of least privilege
    
    **Промпт:** «Сгенерируй список необходимых секретов для деплоя (DB_URL, JWT_SECRET, REGISTRY_TOKEN) и распредели по окружениям.»

---

### **МИКРО-ДЕМО

## **Слайд 13 — «С нуля до CI»**

**Шаги:**

1. Сгенерировать .github/workflows/ci.yml промптом → коммит.
    
2. Добавить Dockerfile и прогнать локальную сборку.
    
3. Запушить тег v0.1.0 → авто-публикация образа (dry-run/скрин).
    

---

### **ПРАКТИКА

## **Слайд 14 — Задание**

**Сделать:**

- Добавить Dockerfile (multi-stage) и .dockerignore.
    
- Создать CI: build+test (PR), publish Docker (tag).
    
- Настроить превью деплой фронта (Pages/Vercel) или публиковать image в реестр.
    
    **Критерии:** пайплайн зелёный; артефакты/образ доступны; нет секретов в коде.

---

## **Слайд 15 — Подсказки промптов (шпаргалка)**

- «Сгенерируй multi-stage Dockerfile (Node/TS, pnpm), объясни слои.»
    
- «Собери docker-compose.yml dev с Postgres и томом, используй .env.»
    
- «Подготовь GitHub Actions: ci.yml (lint+test+build) и release-docker.yml (push GHCR по тэгу).»
    
- «Сделай GitLab .gitlab-ci.yml с dind для публикации образа по тэгу.»
    
- «Дай чек-лист секретов и матрицу окружений (dev/stage/prod).»
    

---

## **Слайд 16 — Чек-лист интеграций**

- Репозиторий подключён, PR/MR шаблон лежит в репо
    
- Dockerfile и .dockerignore добавлены, локально собирается
    
- docker-compose.yml для dev работает
    
- CI: сборка/линт/тест в PR, кэширование включено
    
- CD: публикация образа/превью окружения по событию
    
- Секреты в менеджере, нет секретов в коде
    
- Protected branches + требование статусов перед merge

---

## **Слайд 17 — Анти-паттерны**

- Секреты в репозитории/логах → немедленная ротация
    
- Один «толстый» прод-контейнер для всего → разделяем на сервисы
    
- CI без кэша → медленно и дорого
    
- Деплой без healthcheck/rollback → риск простоя
    
- Нет превью окружений → длинный цикл обратной связи
    
    **Notes:** лечится: кэш buildx/pnpm, healthchecks, поэтапный деплой, Preview Apps.

---

## **Слайд 18 — Итоги

**Тезисы:**

- Cursor + AI генерируют и поддерживают Docker/CI «под ключ»
    
- Интеграции делают билд/тест/деплой воспроизводимым и быстрым